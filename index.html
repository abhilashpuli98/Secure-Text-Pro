// --- Imports ---
// Note: These are loaded via <script> tags in the HTML, so we access them as global variables.
const { jsPDF } = window.jspdf;
const TurndownService = window.TurndownService;

// --- Constants & DOM Elements ---
const API_BASE_URL = 'https://secure-text-pro-backend-1.onrender.com';

const authScreen = document.getElementById('auth-screen');
const mainScreen = document.getElementById('main-screen');
const siteNameInput = document.getElementById('site-name');
const passwordInput = document.getElementById('password');
const accessButton = document.getElementById('access-button');
const authStatus = document.getElementById('auth-status');
const logoutButton = document.getElementById('logout-button');
const statusIndicator = document.getElementById('status-indicator');
const wordCountEl = document.getElementById('word-count');
const charCountEl = document.getElementById('char-count');
const themeToggle = document.getElementById('theme-toggle');
const themeIcon = document.getElementById('theme-icon');
const newNoteBtn = document.getElementById('new-note-btn');
const notesList = document.getElementById('notes-list');
const readModeToggle = document.getElementById('read-mode-toggle');
const editorWrapper = document.getElementById('editor-wrapper');
const readModeView = document.getElementById('read-mode-view');
const currentNoteTitleEl = document.getElementById('current-note-title');
const currentNoteTitleInput = document.getElementById('current-note-title-input');
const editTitleIcon = document.getElementById('edit-title-icon');
const newNoteModal = document.getElementById('new-note-modal');
const newNoteTitleInput = document.getElementById('new-note-title-input');
const cancelNewNoteBtn = document.getElementById('cancel-new-note');
const confirmNewNoteBtn = document.getElementById('confirm-new-note');
const passkeyModal = document.getElementById('passkey-modal');
const passkeyDisplay = document.getElementById('passkey-display');
const passkeyExpiryDisplay = document.getElementById('passkey-expiry-display');
const copyPasskeyBtn = document.getElementById('copy-passkey-btn');
const closePasskeyModalBtn = document.getElementById('close-passkey-modal');
const generatePasskeyBtn = document.getElementById('generate-passkey-btn');
const siteLoginView = document.getElementById('site-login-view');
const passkeyLoginView = document.getElementById('passkey-login-view');
const showPasskeyLogin = document.getElementById('show-passkey-login');
const showSiteLogin = document.getElementById('show-site-login');
const passkeyInput = document.getElementById('passkey-input');
const passkeyLoginButton = document.getElementById('passkey-login-button');
const exportMdBtn = document.getElementById('export-md-btn');
const exportPdfBtn = document.getElementById('export-pdf-btn');
const searchInput = document.getElementById('search-input');
const deleteNoteModal = document.getElementById('delete-note-modal');
const cancelDeleteNoteBtn = document.getElementById('cancel-delete-note');
const confirmDeleteNoteBtn = document.getElementById('confirm-delete-note');

// --- State ---
let quill;
let encryptionKey;
let currentSiteId;
let notes = [];
let activeNoteId = null;
let saveTimeout;
let currentTheme = localStorage.getItem('theme') || 'dark';
let isReadMode = false;
let isReadOnly = false; // --- NEW/FIXED ---
let turndownService;
let noteToDeleteId = null; // --- NEW/FIXED ---
const themes = ['light', 'dark', 'blueprint']; // --- NEW/FIXED ---

// --- Crypto Utils (Your original code) ---
const cryptoUtils = {
    async getKey(password, salt) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
        return window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
        );
    },
    async encrypt(data, key) {
        const text = JSON.stringify(data);
        const enc = new TextEncoder();
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedContent = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, enc.encode(text));
        const encryptedData = new Uint8Array(iv.length + encryptedContent.byteLength);
        encryptedData.set(iv);
        encryptedData.set(new Uint8Array(encryptedContent), iv.length);
        return this.bufferToBase64(encryptedData.buffer);
    },
    async decrypt(encryptedBase64, key) {
        try {
            const encryptedData = this.base64ToBuffer(encryptedBase64);
            const iv = encryptedData.slice(0, 12);
            const data = encryptedData.slice(12);
            const decryptedContent = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
            const decodedText = new TextDecoder().decode(decryptedContent);
            return JSON.parse(decodedText);
        } catch (e) {
            console.error("Decryption failed:", e);
            return null;
        }
    },
    async hash(text) {
        const buffer = await window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(text));
        return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
    },
    bufferToBase64: buffer => btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))),
    base64ToBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    },
    generatePassKeyString() {
        const array = new Uint32Array(4);
        window.crypto.getRandomValues(array);
        return Array.from(array, dec => ('0' + dec.toString(16)).substr(-8)).join('-');
    }
};

// --- Auth Flow (Your original code, slightly modified) ---
const handleSiteLogin = async () => {
    const siteName = siteNameInput.value.trim();
    const password = passwordInput.value;
    if (!siteName || !password) {
        authStatus.textContent = "Site name and password are required.";
        return;
    }
    authStatus.textContent = "";
    accessButton.disabled = true;
    accessButton.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Processing...`;

    try {
        currentSiteId = await cryptoUtils.hash(siteName);
        const salt = new TextEncoder().encode(siteName);
        encryptionKey = await cryptoUtils.getKey(password, salt);

        const response = await fetch(`${API_BASE_URL}/site`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ siteId: currentSiteId })
        });

        if (!response.ok) throw new Error('Network response was not ok.');
        const result = await response.json();

        if (result.exists) {
            const decryptedNotes = await cryptoUtils.decrypt(result.data, encryptionKey);
            if (decryptedNotes === null) {
                authStatus.textContent = "Incorrect password.";
            } else {
                notes = decryptedNotes;
                showMainApp();
            }
        } else {
            notes = [{
                id: Date.now().toString(),
                title: "Welcome Note",
                content: `
                    <h1>Welcome to SecureText Pro.</h1>
                    <p>You’ve unlocked your private vault. Every word you write is encrypted in real time, only your eyes can decode it.</p>
                    <p><br></p>
                    <h2>New Features</h2>
                    <ul>
                        <li>Click the title above to rename this note.</li>
                        <li>Hover over this note in the sidebar to delete it.</li>
                        <li>Use the search bar to find notes.</li>
                        <li>Cycle through Light, Dark, and Blueprint themes!</li>
                    </ul>
                `
            }];
            const saved = await saveAllNotes();
            if (saved) showMainApp();
            else authStatus.textContent = "Failed to create new site.";
        }
    } catch (error) {
        console.error("Error accessing site: ", error);
        authStatus.textContent = "An error occurred. Could not connect to server.";
    } finally {
        if (mainScreen.classList.contains('hidden')) {
            accessButton.disabled = false;
            accessButton.innerHTML = 'Access or Create Site';
        }
    }
};

// --- NEW/FIXED: Passkey Login Flow ---
const handlePassKeyLogin = async () => {
    const passkey = passkeyInput.value.trim();
    if (!passkey) {
        authStatus.textContent = "Pass Key is required.";
        return;
    }
    authStatus.textContent = "";
    passkeyLoginButton.disabled = true;
    passkeyLoginButton.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Logging in...`;

    try {
        // 1. Fetch the encrypted master key and siteId using the passkey
        const response = await fetch(`${API_BASE_URL}/passkey/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ passkey })
        });
        if (!response.ok) throw new Error('Invalid or expired passkey.');
        const { siteId, encryptedKey } = await response.json();
        
        // 2. Derive a key from the passkey string itself to decrypt the master key
        const passkeySalt = new TextEncoder().encode(passkey.slice(0, 8)); // Use part of passkey as salt
        const tempKey = await cryptoUtils.getKey(passkey, passkeySalt);
        
        // 3. Decrypt the master key
        const decryptedMasterKey = await cryptoUtils.decrypt(encryptedKey, tempKey);
        if (!decryptedMasterKey) throw new Error('Passkey decryption failed.');

        // 4. Import the decrypted master key
        encryptionKey = await window.crypto.subtle.importKey(
            "jwk",
            decryptedMasterKey,
            { name: "AES-GCM" },
            true,
            ["encrypt", "decrypt"]
        );
        currentSiteId = siteId;

        // 5. Fetch the site data (notes)
        const siteResponse = await fetch(`${API_BASE_URL}/site`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ siteId: currentSiteId })
        });
        if (!siteResponse.ok) throw new Error('Could not fetch site data.');
        const result = await siteResponse.json();
        
        // 6. Decrypt notes
        const decryptedNotes = await cryptoUtils.decrypt(result.data, encryptionKey);
        if (decryptedNotes === null) throw new Error('Failed to decrypt notes.');

        notes = decryptedNotes;
        isReadOnly = true; // Set read-only mode for passkey login
        showMainApp();

    } catch (error) {
        console.error("Passkey login failed:", error);
        authStatus.textContent = error.message;
    } finally {
        passkeyLoginButton.disabled = false;
        passkeyLoginButton.innerHTML = 'Login with Pass Key';
    }
};

// --- NEW/FIXED: Passkey Generation Flow ---
const handleGeneratePassKey = async () => {
    generatePasskeyBtn.disabled = true;
    generatePasskeyBtn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Generating...`;
    
    try {
        // 1. Generate a new random passkey string
        const passkey = cryptoUtils.generatePassKeyString();
        
        // 2. Export the master key to be encrypted
        const masterKeyJWK = await window.crypto.subtle.exportKey("jwk", encryptionKey);

        // 3. Derive a temporary key from the passkey string
        const passkeySalt = new TextEncoder().encode(passkey.slice(0, 8));
        const tempKey = await cryptoUtils.getKey(passkey, passkeySalt);
        
        // 4. Encrypt the master key with the temporary key
        const encryptedKey = await cryptoUtils.encrypt(masterKeyJWK, tempKey);

        // 5. Send to backend to store
        const response = await fetch(`${API_BASE_URL}/passkey/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ siteId: currentSiteId, encryptedKey, passkey })
        });
        
        if (!response.ok) throw new Error('Failed to generate passkey on server.');
        const { expiry } = await response.json();

        // 6. Show modal with passkey
        passkeyDisplay.textContent = passkey;
        passkeyExpiryDisplay.textContent = new Date(expiry).toLocaleString();
        copyPasskeyBtn.textContent = "Copy";
        showPasskeyModal();

    } catch (error) {
        console.error("Failed to generate passkey:", error);
        statusIndicator.textContent = "Passkey generation failed!";
    } finally {
        generatePasskeyBtn.disabled = false;
        generatePasskeyBtn.innerHTML = '<span>Generate Pass Key</span>';
    }
};

// --- Data & Saving (Your original saveAllNotes, modified status) ---
const saveAllNotes = async () => {
    if (!currentSiteId || !encryptionKey || isReadOnly) return false;
    clearTimeout(saveTimeout);
    saveTimeout = null;
    statusIndicator.textContent = 'Encrypting & Saving...';
    try {
        const encryptedData = await cryptoUtils.encrypt(notes, encryptionKey);
        const response = await fetch(`${API_BASE_URL}/save`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ siteId: currentSiteId, encryptedData })
        });
        if (!response.ok) throw new Error('Save failed');
        statusIndicator.textContent = 'All changes saved ✔';
        return true;
    } catch (error) {
        console.error("Error saving notes:", error);
        statusIndicator.textContent = 'Save failed !';
        return false;
    }
};

// --- NEW/FIXED: Note & Editor Logic ---
const scheduleSave = () => {
    if (isReadOnly) return;
    clearTimeout(saveTimeout);
    statusIndicator.textContent = 'Unsaved changes...';
    saveTimeout = setTimeout(saveAllNotes, 1500);
};

const saveCurrentNote = () => {
    if (isReadOnly || !activeNoteId) return;
    const activeNote = notes.find(n => n.id === activeNoteId);
    if (activeNote) {
        activeNote.content = quill.root.innerHTML;
        scheduleSave();
    }
};

const loadNote = (noteId) => {
    const note = notes.find(n => n.id === noteId);
    if (!note) {
        if (notes.length > 0) loadNote(notes[0].id);
        else {
            quill.setText('');
            currentNoteTitleEl.textContent = 'No Notes';
        }
        return;
    }
    
    activeNoteId = note.id;
    currentNoteTitleEl.textContent = note.title;
    currentNoteTitleEl.classList.remove('hidden');
    currentNoteTitleInput.classList.add('hidden');

    if (quill) {
        quill.root.innerHTML = note.content;
        updateWordCharCount();
        quill.enable(!isReadOnly);
    }
    if (isReadMode) toggleReadMode(true); // Switch to editor view
    renderSidebar(); // To update active state
};

const setupQuill = () => {
    const toolbarOptions = [
        [{ 'header': [1, 2, 3, false] }, { 'font': [] }],
        ['bold', 'italic', 'underline', 'strike', { 'color': [] }, { 'background': [] }],
        [{ 'list': 'ordered'}, { 'list': 'bullet' }, { 'indent': '-1'}, { 'indent': '+1' }],
        ['blockquote', 'code-block', 'link', 'image'],
        ['clean']
    ];

    quill = new Quill('#editor-container', {
        modules: {
            syntax: { highlight: text => hljs.highlightAuto(text).value },
            toolbar: toolbarOptions
        },
        theme: 'snow'
    });
    
    quill.on('text-change', (delta, oldDelta, source) => {
        if (source === 'user') {
            saveCurrentNote();
            updateWordCharCount();
        }
    });
};

const updateWordCharCount = () => {
    const text = quill.getText().trim();
    const words = text.length > 0 ? text.split(/\s+/).length : 0;
    const chars = text.length;
    wordCountEl.textContent = `Words: ${words}`;
    charCountEl.textContent = `Characters: ${chars}`;
};

// --- NEW/FIXED: Sidebar & Note Management ---
const renderSidebar = (filterText = '') => {
    notesList.innerHTML = '';
    
    const filteredNotes = notes.filter(note => {
        const searchText = filterText.toLowerCase();
        const titleMatch = note.title.toLowerCase().includes(searchText);
        // Simple text-only search for content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = note.content;
        const contentMatch = (tempDiv.textContent || tempDiv.innerText || "").toLowerCase().includes(searchText);
        return titleMatch || contentMatch;
    });

    if (filteredNotes.length === 0) {
        notesList.innerHTML = `<span class="text-sm text-gray-400 p-2">No notes found.</span>`;
        return;
    }

    filteredNotes.forEach(note => {
        const item = document.createElement('div');
        item.className = 'note-item group';
        item.dataset.noteId = note.id;
        if (note.id === activeNoteId) {
            item.classList.add('active');
        }
        
        item.innerHTML = `
            <span class="note-item-title">${note.title}</span>
            <button class="note-action-icon" title="Delete Note">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        `;
        
        // Click main item to load note
        item.addEventListener('click', (e) => {
            if (e.target.closest('.note-action-icon')) return; // Don't load if clicking delete
            loadNote(note.id);
        });

        // Click delete icon
        item.querySelector('.note-action-icon').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent loading note
            showDeleteModal(note.id);
        });

        notesList.appendChild(item);
    });
};

const handleCreateNewNote = () => {
    const title = newNoteTitleInput.value.trim() || "Untitled Note";
    const newNote = {
        id: Date.now().toString(),
        title: title,
        content: `<p>Start writing your new note...</p>`
    };
    notes.unshift(newNote); // Add to beginning of array
    newNoteTitleInput.value = '';
    hideNewNoteModal();
    saveAllNotes(); // Save immediately
    loadNote(newNote.id); // Load the new note
    renderSidebar();
};

// --- NEW/FIXED: Note Title Renaming ---
const enableTitleEdit = () => {
    if (isReadOnly) return;
    currentNoteTitleInput.value = currentNoteTitleEl.textContent;
    currentNoteTitleEl.classList.add('hidden');
    currentNoteTitleInput.classList.remove('hidden');
    editTitleIcon.classList.add('hidden');
    currentNoteTitleInput.focus();
};

const saveTitleEdit = () => {
    const newTitle = currentNoteTitleInput.value.trim();
    const activeNote = notes.find(n => n.id === activeNoteId);
    
    if (newTitle && activeNote && newTitle !== activeNote.title) {
        activeNote.title = newTitle;
        currentNoteTitleEl.textContent = newTitle;
        scheduleSave();
        renderSidebar();
    } else {
        currentNoteTitleEl.textContent = activeNote.title;
    }
    
    currentNoteTitleEl.classList.remove('hidden');
    currentNoteTitleInput.classList.add('hidden');
    editTitleIcon.classList.remove('hidden');
};

// --- NEW/FIXED: Note Deletion ---
const showDeleteModal = (noteId) => {
    noteToDeleteId = noteId;
    deleteNoteModal.classList.remove('hidden');
};
const hideDeleteModal = () => {
    noteToDeleteId = null;
    deleteNoteModal.classList.add('hidden');
};
const handleConfirmDelete = () => {
    if (!noteToDeleteId) return;
    
    notes = notes.filter(n => n.id !== noteToDeleteId);
    hideDeleteModal();
    saveAllNotes(); // Save immediately
    
    if (activeNoteId === noteToDeleteId) {
        // If we deleted the active note, load the first one
        activeNoteId = null;
        loadNote(notes.length > 0 ? notes[0].id : null);
    }
    renderSidebar();
};

// --- NEW/FIXED: Export Functions ---
const exportToMarkdown = () => {
    if (!turndownService) {
        turndownService = new TurndownService({ codeBlockStyle: 'fenced' });
    }
    const note = notes.find(n => n.id === activeNoteId);
    if (!note) return;
    
    const markdown = turndownService.turndown(note.content);
    const blob = new Blob([markdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${note.title.replace(/ /g, '_')}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

const exportToPDF = () => {
    const { jsPDF } = window.jspdf;
    const note = notes.find(n => n.id === activeNoteId);
    if (!note) return;

    // Use the read-mode view for a cleaner export
    const exportContent = readModeView;
    exportContent.innerHTML = quill.root.innerHTML; // Temporarily put content in
    exportContent.classList.remove('hidden'); // Must be visible for html2canvas
    editorWrapper.classList.add('hidden'); // Hide editor

    statusIndicator.textContent = 'Generating PDF...';

    html2canvas(exportContent, { scale: 2 }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({
            orientation: 'p',
            unit: 'px',
            format: [canvas.width, canvas.height]
        });
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save(`${note.title.replace(/ /g, '_')}.pdf`);
        
        // Restore view
        exportContent.classList.add('hidden');
        exportContent.innerHTML = '';
        if (!isReadMode) {
            editorWrapper.classList.remove('hidden');
        }
        statusIndicator.textContent = 'All changes saved ✔';
    });
};

// --- NEW/FIXED: UI & Theme Functions ---
const showMainApp = () => {
    setupQuill();
    turndownService = new TurndownService({ codeBlockStyle: 'fenced' });
    
    authScreen.classList.add('hidden');
    mainScreen.classList.remove('hidden');
    
    if (isReadOnly) {
        newNoteBtn.disabled = true;
        generatePasskeyBtn.disabled = true;
        newNoteBtn.title = "Read-only mode";
        generatePasskeyBtn.title = "Read-only mode";
        statusIndicator.textContent = "Read-only mode";
    }

    if (notes.length > 0) {
        loadNote(notes[0].id);
    }
    renderSidebar();
};

const handleLogout = () => {
    // Clear state
    quill = null;
    encryptionKey = null;
    currentSiteId = null;
    notes = [];
    activeNoteId = null;
    isReadOnly = false;
    clearTimeout(saveTimeout);
    
    // Reset UI
    authStatus.textContent = '';
    siteNameInput.value = '';
    passwordInput.value = '';
    passkeyInput.value = '';
    mainScreen.classList.add('hidden');
    authScreen.classList.remove('hidden');
    accessButton.disabled = false;
    accessButton.innerHTML = 'Access or Create Site';
};

const applyTheme = (theme) => {
    document.documentElement.classList.remove('dark', 'blueprint');
    if (theme === 'dark') {
        document.documentElement.classList.add('dark');
    } else if (theme === 'blueprint') {
        document.documentElement.classList.add('blueprint');
    }
    localStorage.setItem('theme', theme);
    updateThemeIcon(theme);
};

const updateThemeIcon = (theme) => {
    if (theme === 'light') {
        themeIcon.innerHTML = `<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>`; // Moon
    } else if (theme === 'dark') {
        themeIcon.innerHTML = `<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-1.04-.18-2.04-.5-2.99M16.5 8.5A.5.5 0 0 0 16 9v2a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5V9a.5.5 0 0 0-.5-.5h-2zM12 7a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5V7.5a.5.5 0 0 0-.5-.5h-2zM7.5 12a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 0-.5-.5h-2z"/>`; // Blueprint-like icon
    } else { // blueprint
        themeIcon.innerHTML = `<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>`; // Sun
    }
};

const toggleTheme = () => {
    let currentThemeIndex = themes.indexOf(currentTheme);
    let nextThemeIndex = (currentThemeIndex + 1) % themes.length;
    currentTheme = themes[nextThemeIndex];
    applyTheme(currentTheme);
};

const toggleReadMode = (forceOff = false) => {
    if (forceOff) isReadMode = true; // Set to true so the next logic block turns it off

    if (isReadMode) {
        editorWrapper.classList.remove('hidden');
        readModeView.classList.add('hidden');
        readModeView.innerHTML = '';
        isReadMode = false;
        readModeToggle.classList.remove('bg-blue-200', 'dark:bg-blue-700');
    } else {
        readModeView.innerHTML = quill.root.innerHTML;
        editorWrapper.classList.add('hidden');
        readModeView.classList.remove('hidden');
        isReadMode = true;
        readModeToggle.classList.add('bg-blue-200', 'dark:bg-blue-700');
    }
};

// --- NEW/FIXED: Modal Show/Hide Utils ---
const showNewNoteModal = () => newNoteModal.classList.remove('hidden');
const hideNewNoteModal = () => newNoteModal.classList.add('hidden');
const showPasskeyModal = () => passkeyModal.classList.remove('hidden');
const hidePasskeyModal = () => passkeyModal.classList.add('hidden');


// --- Event Listeners (All re-implemented or new) ---
applyTheme(currentTheme);
accessButton.addEventListener('click', handleSiteLogin);
passwordInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleSiteLogin());
logoutButton.addEventListener('click', handleLogout);
themeToggle.addEventListener('click', toggleTheme);
readModeToggle.addEventListener('click', () => toggleReadMode());
newNoteBtn.addEventListener('click', showNewNoteModal);
cancelNewNoteBtn.addEventListener('click', hideNewNoteModal);
confirmNewNoteBtn.addEventListener('click', handleCreateNewNote);
newNoteTitleInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleCreateNewNote());
generatePasskeyBtn.addEventListener('click', handleGeneratePassKey);
closePasskeyModalBtn.addEventListener('click', hidePasskeyModal);
copyPasskeyBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(passkeyDisplay.textContent);
    copyPasskeyBtn.textContent = "Copied!";
    setTimeout(() => (copyPasskeyBtn.textContent = "Copy"), 2000);
});
showPasskeyLogin.addEventListener('click', (e) => {
    e.preventDefault();
    authStatus.textContent = '';
    siteLoginView.classList.add('hidden');
    passkeyLoginView.classList.remove('hidden');
});
showSiteLogin.addEventListener('click', (e) => {
    e.preventDefault();
    authStatus.textContent = '';
    passkeyLoginView.classList.add('hidden');
    siteLoginView.classList.remove('hidden');
});
passkeyLoginButton.addEventListener('click', handlePassKeyLogin);
passkeyInput.addEventListener('keypress', (e) => e.key === 'Enter' && handlePassKeyLogin());
exportMdBtn.addEventListener('click', exportToMarkdown);
exportPdfBtn.addEventListener('click', exportToPDF);
searchInput.addEventListener('input', (e) => renderSidebar(e.target.value));
currentNoteTitleEl.addEventListener('click', enableTitleEdit);
editTitleIcon.addEventListener('click', enableTitleEdit);
currentNoteTitleInput.addEventListener('blur', saveTitleEdit);
currentNoteTitleInput.addEventListener('keypress', (e) => e.key === 'Enter' && saveTitleEdit());
cancelDeleteNoteBtn.addEventListener('click', hideDeleteModal);
confirmDeleteNoteBtn.addEventListener('click', handleConfirmDelete);

window.addEventListener('beforeunload', (e) => {
    if (saveTimeout) { // Only warn if there are pending, unsaved changes
        saveAllNotes(); // Try to save one last time
        const confirmationMessage = 'You have unsaved changes. Are you sure you want to leave?';
        e.preventDefault();
        e.returnValue = confirmationMessage;
        return confirmationMessage;
    }
});
